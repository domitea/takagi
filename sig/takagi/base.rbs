module Takagi
  # Base class that every Takagi based app should use.
  #
  # Provides a Sinatra-like DSL for building CoAP servers with support for:
  # - Route registration (GET, POST, PUT, DELETE, OBSERVE)
  # - Middleware stack
  # - Reactor pattern for observables/observers
  # - Multi-protocol servers (UDP, TCP)
  #
  # This class now follows Single Responsibility Principle by delegating
  # specific concerns to focused modules:
  # - ServerLifecycle: Boot, run, spawn operations
  # - MiddlewareManagement: Middleware stack configuration
  # - ReactorManagement: Observable/observer patterns
  #
  # @example Basic usage
  #   class MyAPI < Takagi::Base
  #     get '/temperature' do
  #       { value: 25.5, unit: 'C' }
  #     end
  #   end
  #
  #   MyAPI.run!
  class Base < Router
    self.@router: untyped

    extend ServerLifecycle

    extend MiddlewareManagement

    extend ReactorManagement

    # Returns the global router instance
    #
    # @return [Router] Singleton router instance
    def self.router: () -> untyped

    # Registers an OBSERVE route in the global router (server-side)
    # Use this to make a resource observable by clients
    # @param path [String] The URL path
    # @param block [Proc] The handler function
    def self.observable: (untyped path, ?metadata: ::Hash[untyped, untyped]) { (?) -> untyped } -> untyped

    # Configures CoRE Link Format metadata for an existing route. Handy when
    # you want to declare handlers and metadata separately (e.g., during boot).
    def self.core: (untyped path, ?method: ::Symbol) { (?) -> untyped } -> untyped
  end
end
