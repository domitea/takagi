module Takagi
  # High-level event distribution with threaded/process async delivery.
  # Built on top of ObserveRegistry with zero runtime dependencies.
  #
  # Supports both CoAP Observe style and Pub/Sub style APIs:
  #
  # @example CoAP Observe style
  #   EventBus.observe('sensor.temperature.room1') { |msg| puts msg.body }
  #   EventBus.notify('sensor.temperature.room1', { value: 25.5 })
  #
  # @example Pub/Sub style (aliases)
  #   EventBus.consumer('sensor.temperature.room1') { |msg| puts msg.body }
  #   EventBus.publish('sensor.temperature.room1', { value: 25.5 })
  #
  # @example Request-Reply pattern
  #   reply = EventBus.send_sync('cache.query', { key: 'user:123' }, timeout: 1.0)
  class EventBus
    self.@executor: untyped

    self.@handlers: untyped

    self.@consumers: untyped

    self.@handler_store: untyped

    self.@mutex: untyped

    self.@current_states: untyped

    self.@cleanup: untyped

    self.@last_index: untyped

    self.@message_store: untyped

    class Error < StandardError
    end

    # Event message wrapper (shareable for Ractor)
    class Message
      @address: untyped

      @body: untyped

      @headers: untyped

      @reply_address: untyped

      @timestamp: untyped

      attr_reader address: untyped

      attr_reader body: untyped

      attr_reader headers: untyped

      attr_reader reply_address: untyped

      attr_reader timestamp: untyped

      def initialize: (untyped address, untyped body, ?headers: ::Hash[untyped, untyped], ?reply_address: untyped?) -> void

      # Reply to this message (request-reply pattern)
      def reply: (untyped body, ?headers: ::Hash[untyped, untyped]) -> (nil | untyped)

      private

      def deep_freeze: (untyped obj) -> untyped
    end

    # Event handler wrapper
    class Handler
      @address: untyped

      @block: untyped

      @options: untyped

      @local_only: untyped

      @pool_id: untyped

      attr_reader address: untyped

      attr_reader block: untyped

      attr_reader options: untyped

      attr_reader pool_id: untyped

      def initialize: (untyped address, ?::Hash[untyped, untyped] options) { (?) -> untyped } -> void

      def call: (untyped message) -> untyped

      def local_only?: () -> untyped
    end

    # Helper method to get configuration with fallback to ENV
    def self.config_value: (untyped config_key, untyped env_key, untyped default) -> untyped

    # Publish message to all subscribers (pub/sub pattern)
    # @param address [String] Event address (e.g., "sensor.temperature.room1")
    # @param body [Object] Message body (must be shareable for Ractors)
    # @param headers [Hash] Optional message headers
    # @return [Message] Published message
    #
    # @example
    #   EventBus.publish('sensor.temperature.room1', { value: 25.5, unit: 'C' })
    def self.publish: (untyped address, ?untyped? body, ?headers: ::Hash[untyped, untyped]) -> untyped

    # Send message to single consumer (point-to-point pattern)
    # Uses round-robin if multiple consumers registered
    # @param address [String] Event address
    # @param body [Object] Message body
    # @param headers [Hash] Optional headers
    # @yield [reply_message] Optional reply handler (request-reply pattern)
    # @return [Message] Sent message
    #
    # @example
    #   EventBus.send('cache.query', { key: 'user:123' }) do |reply|
    #     puts "Cache value: #{reply.body[:value]}"
    #   end
    def self.send: (untyped address, ?untyped? body, ?headers: ::Hash[untyped, untyped]) ?{ (?) -> untyped } -> untyped

    # Synchronous send with timeout (blocking)
    # @param address [String] Event address
    # @param body [Object] Message body
    # @param headers [Hash] Optional headers
    # @param timeout [Float] Timeout in seconds (default: 1.0)
    # @return [Message] Reply message
    # @raise [Timeout::Error] If no reply received within timeout
    #
    # @example
    #   reply = EventBus.send_sync('cache.query', { key: 'user:123' }, timeout: 1.0)
    #   puts "Cache hit: #{reply.body[:hit]}"
    def self.send_sync: (untyped address, ?untyped? body, ?headers: ::Hash[untyped, untyped], ?timeout: ::Float) -> untyped

    # Asynchronous send with Future (non-blocking)
    # @param address [String] Event address
    # @param body [Object] Message body
    # @param headers [Hash] Optional headers
    # @return [Future] Future that will contain reply
    #
    # @example
    #   future = EventBus.send_async('cache.query', { key: 'user:123' })
    #   # ... do other work ...
    #   reply = future.value(timeout: 1.0)
    def self.send_async: (untyped address, ?untyped? body, ?headers: ::Hash[untyped, untyped]) -> untyped

    # Register consumer for address (point-to-point or pub/sub)
    # @param address [String] Event address or pattern
    # @param options [Hash] Handler options
    # @option options [Boolean] :local_only Only receive local messages
    # @yield [message] Block called when message received
    # @return [String] Consumer ID (for unregistering)
    #
    # @example
    #   id = EventBus.consumer('sensor.temperature.room1') do |message|
    #     puts "Temp: #{message.body[:value]}"
    #   end
    #   EventBus.unregister(id)
    def self.consumer: (untyped address, ?::Hash[untyped, untyped] options) ?{ (?) -> untyped } -> untyped

    # Unregister a consumer
    # @param consumer_id [String] Consumer ID returned from consumer()
    def self.unregister: (untyped consumer_id) -> (nil | untyped)

    # Subscribe to remote CoAP observable
    # @param address [String] Event address
    # @param node_url [String] Remote node URL (e.g., 'coap://building-a:5683')
    # @yield [message] Block called when remote notification received
    # @return [String] Subscription ID
    #
    # @example
    #   id = EventBus.subscribe_remote('sensor.temp.buildingA', 'coap://building-a:5683') do |msg|
    #     puts "Remote temp: #{msg.body[:value]}"
    #   end
    def self.subscribe_remote: (untyped address, untyped node_url) { (?) -> untyped } -> untyped

    alias self.observe self.consumer

    alias self.on self.consumer

    alias self.notify self.publish

    alias self.emit self.publish

    alias self.cancel self.unregister

    alias self.subscribe self.subscribe_remote

    alias self.unsubscribe self.unregister

    # Configure message store (for buffering/replay)
    # @param store [MessageBuffer, Object] Message store instance (nil to disable)
    # @return [MessageBuffer, Object, nil] Configured store
    #
    # @example Enable default buffering
    #   EventBus.enable_message_buffering
    #
    # @example Custom configuration
    #   EventBus.configure_message_store(
    #     MessageBuffer.new(max_messages: 200, ttl: 600)
    #   )
    #
    # @example Custom plugin store
    #   EventBus.configure_message_store(RedisMessageStore.new)
    def self.configure_message_store: (untyped store) -> untyped

    # Enable default message buffering
    # @param max_messages [Integer] Max messages per address
    # @param ttl [Integer] Time-to-live in seconds
    # @return [MessageBuffer] Configured buffer
    def self.enable_message_buffering: (?max_messages: ::Integer, ?ttl: ::Integer) -> untyped

    # Disable message buffering
    def self.disable_message_buffering: () -> untyped

    # Get current message store
    # @return [MessageBuffer, Object, nil] Current message store
    attr_reader self.message_store: untyped

    # Replay buffered messages for an address
    # @param address [String] Event address
    # @param since [Time, nil] Return messages since this time (nil = all)
    # @return [Array<Message>] Buffered messages
    #
    # @example Replay all buffered messages
    #   EventBus.replay('sensor.temperature.room1')
    #
    # @example Replay last 60 seconds
    #   EventBus.replay('sensor.temperature.room1', since: Time.now - 60)
    def self.replay: (untyped address, ?since: untyped?) -> (::Array[untyped] | untyped)

    # Replay buffered messages to a consumer
    # Useful for late joiners or reconnecting nodes
    # @param address [String] Event address
    # @param since [Time, nil] Replay messages since this time
    # @yield [message] Block called for each buffered message
    #
    # @example Replay to new subscriber
    #   EventBus.consumer('sensor.temperature.room1') do |msg|
    #     puts "Temp: #{msg.body[:value]}"
    #   end
    #   # Catch up on last 5 minutes
    #   EventBus.replay_to('sensor.temperature.room1', since: Time.now - 300) do |msg|
    #     puts "Missed: #{msg.body[:value]}"
    #   end
    def self.replay_to: (untyped address, ?since: untyped?) ?{ (?) -> untyped } -> untyped

    # Check if address is distributed via CoAP
    # Uses AddressPrefix registry for extensibility
    # @param address [String] Event address
    # @return [Boolean]
    def self.distributed?: (untyped address) -> untyped

    # Check if address is local-only
    # Uses AddressPrefix registry for extensibility
    # @param address [String] Event address
    # @return [Boolean]
    def self.local_only?: (untyped address) -> untyped

    # Get current state for address
    # @param address [String] Event address
    # @return [Object, nil] Current state or nil
    def self.current_state: (untyped address) -> untyped

    # List all registered addresses
    # @return [Array<String>] Event addresses
    def self.addresses: () -> untyped

    # Get handler count for address
    # @param address [String] Event address
    # @return [Integer] Number of handlers
    def self.handler_count: (untyped address) -> untyped

    # Get EventBus statistics
    # @return [Hash] Statistics
    def self.stats: () -> untyped

    # Start background cleanup
    def self.start_cleanup: () -> untyped

    # Stop background cleanup
    def self.stop_cleanup: () -> untyped

    # Shutdown EventBus (cleanup resources)
    def self.shutdown: () -> untyped

    private

    # Get all handlers for exact address match
    def self.handlers_for: (untyped address) -> untyped

    # Get handlers matching wildcard patterns
    # Supports: "sensor.*", "sensor.*.room1"
    def self.wildcard_handlers: (untyped address) -> untyped

    # Match address parts against pattern
    def self.match_pattern?: (untyped parts, untyped pattern_parts) -> (false | untyped)

    # Round-robin selection of next handler
    def self.next_handler_for: (untyped address) -> (nil | untyped)

    public

    def self.handler_for_pool_id: (untyped pool_id) -> untyped

    private

    # Deliver message asynchronously via Ractor pool
    def self.deliver_async: (untyped handler, untyped message) -> untyped

    # Generate unique reply address
    def self.generate_reply_address: () -> ::String

    # Log debug message
    def self.log_debug: (untyped message) -> (nil | untyped)
  end
end
